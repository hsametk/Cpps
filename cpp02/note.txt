Orthodox Canonical Form Nedir?

Bir sÄ±nÄ±fÄ±n â€œcanonicalâ€ yani doÄŸru, standart, eksiksiz kabul edilebilmesi iÃ§in 4 fonksiyonun 
tanÄ±mlanmasÄ± gerekir.

Ã‡Ã¼nkÃ¼ bir sÄ±nÄ±fÄ±n:

OluÅŸturulmasÄ±
Bu zaten diÄŸer cpp lerde de yaptÄ±ÄŸÄ±mÄ±z ÅŸey.

KopyalanmasÄ±
Bir nesne yeni oluÅŸturulurken, baÅŸka bir nesneden kopyalanÄ±yorsa Ã§alÄ±ÅŸÄ±r.

Birbirine atanmasÄ±
Zaten var olan bir nesne baÅŸka bir nesneye eÅŸitlendiÄŸinde Ã§aÄŸrÄ±lÄ±r.

Yok edilmesi
Buda default olarak yaptÄ±ÄŸÄ±mÄ±z ÅŸeylerde.
gibi hayattaki tÃ¼m olaylar dÃ¼zenli ve gÃ¼venli bir ÅŸekilde gerÃ§ekleÅŸmelidir.


Orthodox Canonical Form, bir C++ sÄ±nÄ±fÄ±nÄ±n gÃ¼venli ve doÄŸru ÅŸekilde kopyalanabilmesi, taÅŸÄ±nabilmesi ve 
yok edilebilmesi iÃ§in gerekli olan 4 fonksiyonun (default ctor, copy ctor, copy assignment operator, destructor)
birlikte tanÄ±mlanmasÄ±dÄ±r.
Bunlar sÄ±nÄ±fÄ±n tam yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ kontrol eder ve C++â€™ta bellek gÃ¼venliÄŸi iÃ§in temel bir best practiceâ€™tir.

//Ex00 iÃ§in fonksiyonlarÄ± nasÄ±l atadÄ±ÄŸÄ±na bak ve main e Ã§alÄ±ÅŸ.


//Ex01

fracBits virgÃ¼lÃ¼ kaÃ§ bit saÄŸa kaydÄ±rÄ±p virgÃ¼llÃ¼ haale getireceÄŸimizi belirleyen sayÄ±.
Normalde float sayÄ±lar binary olarak saklanÄ±r ve bazÄ± sayÄ±lar tam temsil edilemez.

Ã–rnek:
0.1 + 0.2 = 0.3000000004 (precision kaybÄ±)

BazÄ± sistemlerde (gÃ¶mÃ¼lÃ¼ cihaz, DSP, bazÄ± grafik motorlarÄ±) float desteklenmez veya Ã§ok yavaÅŸtÄ±r.
Bu yÃ¼zden float yerine integer kullanarak virgÃ¼llÃ¼ sayÄ± simÃ¼le ederiz.

Bu sisteme fixed point denir.

//Fixed point mantÄ±ÄŸÄ±
gerÃ§ek sayÄ± * 2^fractionBits = integer

_raw bizim sayÄ±mÄ±z, static const int _fracBits = 8;

2^8 = 256

Ã–rnek
3.5 * 256 = 896   _raw = 896

//int --> fixed dÃ¶nÃ¼ÅŸÃ¼mÃ¼
Bir tam sayÄ± zaten virgÃ¼lsÃ¼zdÃ¼r.

raw= int_value *256
_raw = n << _fracBits

//bir sayÄ±yÄ± 8 bit sola kaydÄ±rmak 256 ile Ã§armak ile aynÄ±dÄ±r.

//float --> fixed dÃ¶nÃ¼ÅŸÃ¼mÃ¼
raw = roundf(float_value * 256)
5.75 * 256 = 1472

c++ da _raw = roundf(f * (1 << _fracBits));
Neden roudf?
Ã§Ã¼nkÃ¼ raw intager olmak zorunda yuvarlama yapÄ±lmazsa veri kaymasÄ± oluÅŸturulurken


//Fixed --> float dÃ¶nÃ¼ÅŸÃ¼mÃ¼
Fixed formdaki sayÄ±yÄ± tekrar normal hayattaki float'a Ã§evirmek iÃ§in:
float_value = raw / 256.0f



//fixed --> int dÃ¶ngÃ¼sÃ¼mÃ¼
int_value = raw / 256
return _raw >> _fracBits



// 6. operator<< overload

SabitleÅŸtirilmiÅŸ sayÄ± aslÄ±nda iÃ§eride integer.


//Ã¶zet
EX01, fixed-point mantÄ±ÄŸÄ±nÄ±n matematiksel kÄ±smÄ±nÄ± gerÃ§ekleÅŸtiriyor.

Intâ€™leri fixed forma Ã§evirmek iÃ§in raw = n << _fracBits kullanÄ±yoruz.

Floatâ€™larÄ± Ã§evirirken roundf(f * (2^fracBits)) yapÄ±yoruz.

toFloat() fonksiyonu fixed deÄŸeri gerÃ§ek bir floatâ€™a dÃ¶ndÃ¼rÃ¼yor: raw / 256.

toInt() ise 256â€™ya bÃ¶lÃ¼p tam sayÄ±yÄ± alÄ±yor: raw >> 8.

operator<< overload ederek fixed point deÄŸerini float gibi yazdÄ±rÄ±yoruz.

BÃ¶ylece kendi yaptÄ±ÄŸÄ±mÄ±z tarzda bir â€œfloatâ€ veri tipi yaratmÄ±ÅŸ oluyoruz ama iÃ§eride tamamen integer aritmetiÄŸi kullanÄ±yoruz.



//ex02

EX02 Ä°Ã§inde Ã–ÄŸretilen Ana Kavramlar

Operator overloading

Fixed-point aritmetiÄŸi

Prefix & postfix farkÄ±

static fonksiyon mantÄ±ÄŸÄ±

const correctness

Return by reference vs. return by value

â— Ama kendi sÄ±nÄ±fÄ±nÄ± (Fixed) toplamak isteyince NE OLUR?
Fixed a(1.5f);
Fixed b(2.25f);

Fixed c = a + b;   // HATA!


Dil ÅŸunu sorar:

â€œBen Fixed tipi iÃ§in + nasÄ±l Ã§alÄ±ÅŸÄ±r bilmiyorum.â€

C++ built-in tipler iÃ§in +â€™yÄ± biliyor,
ama senin sÄ±nÄ±fÄ±n iÃ§in bilmiyor.

Ä°ÅŸte tam burada devreye giriyor:

âœ… 2) OperatÃ¶r overloading neden var?

C++ bize diyor ki:

â€œHazÄ±r operatÃ¶rleri kendi sÄ±nÄ±fÄ±n iÃ§in yeniden tanÄ±mlayabilirsin.â€

Bunun adÄ± operator overloading.

Sen kendi sÄ±nÄ±fÄ±na ÅŸunu Ã¶ÄŸretiyorsun:
â€œFixed+Fixed â†’ nasÄ±l toplanÄ±r?â€

Ã–rnek:

Fixed Fixed::operator+(const Fixed& rhs) const {
    Fixed result;
    result._raw = this->_raw + rhs._raw;
    return result;
}


Bu sayede ÅŸunu kullanabiliyorsun:

Fixed c = a + b;


Yani operatÃ¶r C++â€™ta zaten var,
ama senin sÄ±nÄ±fÄ±n iÃ§in yok.

Senin gÃ¶revin:
dilin operatÃ¶rlerini kendi sÄ±nÄ±fÄ±na adapte etmek.

amaÃ§ operator overloading i Ã¶ÄŸretmek.


//KopyalamanÄ±n farklarÄ±
KÄ±sa ve net Ã¶zet ğŸ‘‡

âœ… Shallow Copy (YÃ¼zeysel Kopya)

Sadece deÄŸerleri kopyalar.

Pointer varsa adresini kopyalar â†’ iki obje aynÄ± belleÄŸi paylaÅŸÄ±r.

Dinamik bellek varsa tehlikeli olabilir.

âœ… Deep Copy (Derin Kopya)

Hem deÄŸerleri hem de pointerâ€™Ä±n gÃ¶sterdiÄŸi veriyi kopyalar.

Her objeye ayrÄ± bir bellek alanÄ± verir.

Dinamik bellek kullanan sÄ±nÄ±flarda gÃ¼venli ve gereklidir.
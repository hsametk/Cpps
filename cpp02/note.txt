Orthodox Canonical Form Nedir?

Bir sÄ±nÄ±fÄ±n â€œcanonicalâ€ yani doÄŸru, standart, eksiksiz kabul edilebilmesi iÃ§in 4 fonksiyonun 
tanÄ±mlanmasÄ± gerekir.

Ã‡Ã¼nkÃ¼ bir sÄ±nÄ±fÄ±n:

OluÅŸturulmasÄ±
Bu zaten diÄŸer cpp lerde de yaptÄ±ÄŸÄ±mÄ±z ÅŸey.

KopyalanmasÄ±
Bir nesne yeni oluÅŸturulurken, baÅŸka bir nesneden kopyalanÄ±yorsa Ã§alÄ±ÅŸÄ±r.

Birbirine atanmasÄ±
Zaten var olan bir nesne baÅŸka bir nesneye eÅŸitlendiÄŸinde Ã§aÄŸrÄ±lÄ±r.

Yok edilmesi
Buda default olarak yaptÄ±ÄŸÄ±mÄ±z ÅŸeylerde.
gibi hayattaki tÃ¼m olaylar dÃ¼zenli ve gÃ¼venli bir ÅŸekilde gerÃ§ekleÅŸmelidir.


Orthodox Canonical Form, bir C++ sÄ±nÄ±fÄ±nÄ±n gÃ¼venli ve doÄŸru ÅŸekilde kopyalanabilmesi, taÅŸÄ±nabilmesi ve 
yok edilebilmesi iÃ§in gerekli olan 4 fonksiyonun (default ctor, copy ctor, copy assignment operator, destructor)
birlikte tanÄ±mlanmasÄ±dÄ±r.
Bunlar sÄ±nÄ±fÄ±n tam yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ kontrol eder ve C++â€™ta bellek gÃ¼venliÄŸi iÃ§in temel bir best practiceâ€™tir.

//Ã–nemli
_fracBits bir â€œsÄ±nÄ±f sabitiâ€dir. Bu yÃ¼zden static const yapÄ±lÄ±r.

//Ex00 iÃ§in fonksiyonlarÄ± nasÄ±l atadÄ±ÄŸÄ±na bak ve main e Ã§alÄ±ÅŸ.


//Ex01

fracBits virgÃ¼lÃ¼ kaÃ§ bit saÄŸa kaydÄ±rÄ±p virgÃ¼llÃ¼ haale getireceÄŸimizi belirleyen sayÄ±.
Normalde float sayÄ±lar binary olarak saklanÄ±r ve bazÄ± sayÄ±lar tam temsil edilemez.

Ã–rnek:
0.1 + 0.2 = 0.3000000004 (precision kaybÄ±)

BazÄ± sistemlerde (gÃ¶mÃ¼lÃ¼ cihaz, DSP, bazÄ± grafik motorlarÄ±) float desteklenmez veya Ã§ok yavaÅŸtÄ±r.
Bu yÃ¼zden float yerine integer kullanarak virgÃ¼llÃ¼ sayÄ± simÃ¼le ederiz.

Bu sisteme fixed point denir.

//Fixed point mantÄ±ÄŸÄ±
gerÃ§ek sayÄ± * 2^fractionBits = integer

_raw bizim sayÄ±mÄ±z, static const int _fracBits = 8;

2^8 = 256

Ã–rnek
3.5 * 256 = 896   _raw = 896

//int --> fixed dÃ¶nÃ¼ÅŸÃ¼mÃ¼
Bir tam sayÄ± zaten virgÃ¼lsÃ¼zdÃ¼r.

raw= int_value *256
_raw = n << _fracBits

//bir sayÄ±yÄ± 8 bit sola kaydÄ±rmak 256 ile Ã§armak ile aynÄ±dÄ±r.

//float --> fixed dÃ¶nÃ¼ÅŸÃ¼mÃ¼
raw = roundf(float_value * 256)
5.75 * 256 = 1472

c++ da _raw = roundf(f * (1 << _fracBits));
Neden roudf?
Ã§Ã¼nkÃ¼ raw intager olmak zorunda yuvarlama yapÄ±lmazsa veri kaymasÄ± oluÅŸturulurken


//Fixed --> float dÃ¶nÃ¼ÅŸÃ¼mÃ¼
Fixed formdaki sayÄ±yÄ± tekrar normal hayattaki float'a Ã§evirmek iÃ§in:
float_value = raw / 256.0f



//fixed --> int dÃ¶ngÃ¼sÃ¼mÃ¼
int_value = raw / 256
return _raw >> _fracBits



// 6. operator<< overload

SabitleÅŸtirilmiÅŸ sayÄ± aslÄ±nda iÃ§eride integer.


//Ã¶zet
EX01, fixed-point mantÄ±ÄŸÄ±nÄ±n matematiksel kÄ±smÄ±nÄ± gerÃ§ekleÅŸtiriyor.

Intâ€™leri fixed forma Ã§evirmek iÃ§in raw = n << _fracBits kullanÄ±yoruz.

Floatâ€™larÄ± Ã§evirirken roundf(f * (2^fracBits)) yapÄ±yoruz.

toFloat() fonksiyonu fixed deÄŸeri gerÃ§ek bir floatâ€™a dÃ¶ndÃ¼rÃ¼yor: raw / 256.

toInt() ise 256â€™ya bÃ¶lÃ¼p tam sayÄ±yÄ± alÄ±yor: raw >> 8.

operator<< overload ederek fixed point deÄŸerini float gibi yazdÄ±rÄ±yoruz.

BÃ¶ylece kendi yaptÄ±ÄŸÄ±mÄ±z tarzda bir â€œfloatâ€ veri tipi yaratmÄ±ÅŸ oluyoruz ama iÃ§eride tamamen integer aritmetiÄŸi kullanÄ±yoruz.



//ex02

EX02 Ä°Ã§inde Ã–ÄŸretilen Ana Kavramlar

Operator overloading

Fixed-point aritmetiÄŸi

Prefix & postfix farkÄ±

static fonksiyon mantÄ±ÄŸÄ±

const correctness

Return by reference vs. return by value

â— Ama kendi sÄ±nÄ±fÄ±nÄ± (Fixed) toplamak isteyince NE OLUR?
Fixed a(1.5f);
Fixed b(2.25f);

Fixed c = a + b;   // HATA!


Dil ÅŸunu sorar:

â€œBen Fixed tipi iÃ§in + nasÄ±l Ã§alÄ±ÅŸÄ±r bilmiyorum.â€

C++ built-in tipler iÃ§in +â€™yÄ± biliyor,
ama senin sÄ±nÄ±fÄ±n iÃ§in bilmiyor.

Ä°ÅŸte tam burada devreye giriyor:

âœ… 2) OperatÃ¶r overloading neden var?

C++ bize diyor ki:

â€œHazÄ±r operatÃ¶rleri kendi sÄ±nÄ±fÄ±n iÃ§in yeniden tanÄ±mlayabilirsin.â€

Bunun adÄ± operator overloading.

Sen kendi sÄ±nÄ±fÄ±na ÅŸunu Ã¶ÄŸretiyorsun:
â€œFixed+Fixed â†’ nasÄ±l toplanÄ±r?â€

Ã–rnek:

Fixed Fixed::operator+(const Fixed& rhs) const {
    Fixed result;
    result._raw = this->_raw + rhs._raw;
    return result;
}


Bu sayede ÅŸunu kullanabiliyorsun:

Fixed c = a + b;


Yani operatÃ¶r C++â€™ta zaten var,
ama senin sÄ±nÄ±fÄ±n iÃ§in yok.

Senin gÃ¶revin:
dilin operatÃ¶rlerini kendi sÄ±nÄ±fÄ±na adapte etmek.

amaÃ§ operator overloading i Ã¶ÄŸretmek.


//KopyalamanÄ±n farklarÄ±
KÄ±sa ve net Ã¶zet ğŸ‘‡

âœ… Shallow Copy (YÃ¼zeysel Kopya)

Sadece deÄŸerleri kopyalar.

Pointer varsa adresini kopyalar â†’ iki obje aynÄ± belleÄŸi paylaÅŸÄ±r.

Dinamik bellek varsa tehlikeli olabilir.

âœ… Deep Copy (Derin Kopya)

Hem deÄŸerleri hem de pointerâ€™Ä±n gÃ¶sterdiÄŸi veriyi kopyalar.

Her objeye ayrÄ± bir bellek alanÄ± verir.

Dinamik bellek kullanan sÄ±nÄ±flarda gÃ¼venli ve gereklidir.


std::ostream& operator<<(std::ostream& os, const Fixed& fixed)
{
    os << fixed.toFloat();
    return (os);
}

bu nedir ve neden kullanÄ±yoruz?
fonksiyon amacÄ± cout << fixedObj; yazabilmeni saÄŸlar.
Ã‡Ã¼nkÃ¼ C++ "Fixed nasÄ±l yazdÄ±rÄ±lÄ±r?" bilmiyor.

Bu fonksiyon ÅŸunu saÄŸlar:

std::cout << fixedObj;


os â†’ Ã§Ä±ktÄ± akÄ±mÄ± (cout)

fixed â†’ yazdÄ±rÄ±lacak nesne

fixed.toFloat() â†’ floatâ€™a Ã§evirip yazdÄ±rÄ±yor

return os; â†’ zincirleme yazdÄ±rmayÄ± mÃ¼mkÃ¼n kÄ±lÄ±yor.

fonksiyonun sonundaki constlara tekrar bak
âœ… 1) Pre-increment / Post-increment operatÃ¶rlerinde const KULLANAMAZSIN

AÅŸaÄŸÄ±dakiler:

Fixed& Fixed::operator++()
Fixed Fixed::operator++(int)
Fixed& Fixed::operator--()
Fixed Fixed::operator--(int)


const olamaz Ã§Ã¼nkÃ¼:

Bu operatÃ¶rler objeyi deÄŸiÅŸtirir (_raw++, _raw--).

const Ã¼ye fonksiyon demek: objeyi deÄŸiÅŸtirmeyeceÄŸim demektir.

Bu operatÃ¶rlerin amacÄ± zaten sayÄ±nÄ±n deÄŸerini deÄŸiÅŸtirmektir.

| Fonksiyon                         | const olabilir mi?                          | Neden?                        |
| --------------------------------- | ------------------------------------------- | ----------------------------- |
| `operator++()`                    | âŒ                                           | nesneyi deÄŸiÅŸtiriyor          |
| `operator++(int)`                 | âŒ                                           | nesneyi deÄŸiÅŸtiriyor          |
| `operator--()`                    | âŒ                                           | nesneyi deÄŸiÅŸtiriyor          |
| `operator--(int)`                 | âŒ                                           | nesneyi deÄŸiÅŸtiriyor          |
| `min(Fixed&, Fixed&)`             | âŒ                                           | non-const referans dÃ¶ndÃ¼rÃ¼yor |
| `min(const Fixed&, const Fixed&)` | âš ï¸ Teknik olarak olabilir ama gerekli deÄŸil | Ã§Ã¼nkÃ¼ this kullanÄ±lmÄ±yor      |
| `max(Fixed&, Fixed&)`             | âŒ                                           | non-const referans dÃ¶ndÃ¼rÃ¼yor |
| `max(const Fixed&, const Fixed&)` | âš ï¸ Olabilir ama **subject bunu beklemiyor** | anlamsÄ±z const                |

int â†’ postfix (++/--) operatÃ¶rÃ¼nÃ¼ ayÄ±rmak iÃ§in C++â€™Ä±n istediÄŸi dummy parametredir.

Ä°Ã§eride kullanÄ±lmaz.

DeÄŸer taÅŸÄ±maz.

Sadece "bu postfix" demek iÃ§indir.


//nedne os returnlenir

zincirleme yazÄ±labilmesi iÃ§in





//
std::ostream& operator<<(std::ostream& os, const Fixed& fixed);
neden class Ä±n dÄ±ÅŸÄ±nda yazÄ±lÄ±yor

operator<< sÄ±nÄ±fÄ±n dÄ±ÅŸÄ±nda yazÄ±lÄ±r Ã§Ã¼nkÃ¼ sol operand std::ostreamâ€™dir ve onun Ã¼ye operatÃ¶rÃ¼nÃ¼ deÄŸiÅŸtiremezsin.
C++â€™ta sol operand sÄ±nÄ±fÄ±n kendisi olmadÄ±kÃ§a operatÃ¶rÃ¼ sÄ±nÄ±f iÃ§ine yazamazsÄ±n.

Bu nedenle global/friend olarak yazÄ±lÄ±r.

